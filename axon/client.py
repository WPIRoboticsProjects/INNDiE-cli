import json
import tempfile

import click
import boto3
import ipify
import webbrowser
import os.path

all_perm = {
    "FromPort": -1,
    "IpProtocol": "-1",
    "IpRanges": [{"CidrIp": "0.0.0.0/0"}],
    "Ipv6Ranges": [{"CidrIpv6": "::/0"}],
    "ToPort": -1
}

all_http_perm = {
    "FromPort": 80,
    "IpProtocol": "tcp",
    "IpRanges": [{"CidrIp": "0.0.0.0/0"}],
    "Ipv6Ranges": [{"CidrIpv6": "::/0"}],
    "ToPort": 80
}


def make_client(name, region):
    if region is None:
        return boto3.client(name)
    else:
        return boto3.client(name, region_name=region)


def make_resource(name):
    return boto3.resource(name)


def ensure_log_group(group_name, region):
    """
    Ensures that a log group is present. If there is a matching log group, nothing is created.
    If there is no matching log group, one is created.

    :param group_name: The name of the log group.
    :param region: The region, or `None` to pull the region from the environment.
    :return: Nothing.
    """
    client = make_client("logs", region)
    matching_log_groups = client.describe_log_groups(
        logGroupNamePrefix=group_name
    )
    log_groups = matching_log_groups["logGroups"]
    log_group_names = [it["logGroupName"] for it in log_groups]

    if group_name in log_group_names:
        # The log group exists, nothing else to do
        return
    else:
        # The log group needs to be created
        client.create_log_group(logGroupName=group_name)
        return


def revoke_all_perms(sg):
    """
    Revokes all permissions from the SecurityGroup.

    :param sg: The SecurityGroup.
    """
    if len(sg.ip_permissions) > 0:
        sg.revoke_ingress(IpPermissions=sg.ip_permissions)

    if len(sg.ip_permissions_egress) > 0:
        sg.revoke_egress(IpPermissions=sg.ip_permissions_egress)


def ensure_ecs_gress(sg_id, region):
    """
    Rewrites the ingress and egress permissions for the SecurityGroup. All existing ingress and
    egress permissions are revoked. The permissions that Axon needs are authorized.

    :param sg_id: The SecurityGroup's GroupId.
    :param region: The region, or `None` to pull the region from the environment.
    :return: Nothing.
    """
    ec2 = boto3.resource('ec2', region_name=region)
    sg = ec2.SecurityGroup(sg_id)

    revoke_all_perms(sg)

    ip = ipify.get_ip()
    axon_tcp_perm = {
        "FromPort": 8080,
        "IpProtocol": "tcp",
        "IpRanges": [{"CidrIp": "{}/32".format(ip)}],
        "ToPort": 8080
    }

    sg.authorize_egress(IpPermissions=[all_perm])
    sg.authorize_ingress(IpPermissions=[axon_tcp_perm])


def ensure_ec2_gress(sg_id, region):
    """
    Rewrites the ingress and egress permissions for the SecurityGroup. All existing ingress and
    egress permissions are revoked. The permissions that Axon needs are authorized.

    :param sg_id: The SecurityGroup's GroupId.
    :param region: The region, or `None` to pull the region from the environment.
    :return: Nothing.
    """
    ec2 = boto3.resource('ec2', region_name=region)
    sg = ec2.SecurityGroup(sg_id)

    revoke_all_perms(sg)

    sg.authorize_egress(IpPermissions=[all_perm])
    sg.authorize_ingress(IpPermissions=[all_http_perm])


def get_single_security_group(client, sg_name, desc):
    """
    Ensures that exactly one matching SecurityGroup exists. If there is one match, its permissions
    are remade. If there is more than one match, a RuntimeError is raised. If there are no matches,
    a new SecurityGroup is made.

    :param client: The EC2 client to use.
    :param sg_name: The name of the SecurityGroup.
    :param desc: The description of the SecurityGroup, if it needs to be created.
    :return: The GroupId of the matching SecurityGroup.
    """
    security_groups = client.describe_security_groups(
        Filters=[
            {
                "Name": "group-name",
                "Values": [sg_name]
            }
        ]
    )["SecurityGroups"]

    sgs = [it for it in security_groups if it["GroupName"] == sg_name]
    if len(sgs) > 1:
        raise RuntimeError("Matched multiple security groups: {}".format(sgs))

    if len(sgs) == 1:
        # The SG already exists
        sg = sgs[0]
        sg_id = sg["GroupId"]
    else:
        sg_id = client.create_security_group(
            Description=desc,
            GroupName=sg_name
        )["GroupId"]

    return sg_id


def ensure_ecs_security_group(region):
    """
    Ensures that the ECS SecurityGroup exists.
    :param region: The region, or `None` to pull the region from the environment.
    :return: The GroupId of the SecurityGroup.
    """
    sg_name = "axon-autogenerated-ecs-sg"
    client = make_client("ec2", region)
    sg_id = get_single_security_group(client, sg_name, "Axon autogenerated for ECS.")
    ensure_ecs_gress(sg_id, region)
    return sg_id


def ensure_ec2_security_group(region):
    """
    Ensures that the EC2 SecurityGroup exists.
    :param region: The region, or `None` to pull the region from the environment.
    :return: The GroupId of the SecurityGroup.
    """
    sg_name = "axon-autogenerated-ec2-sg"
    client = make_client("ec2", region)
    sg_id = get_single_security_group(client, sg_name, "Axon autogenerated for EC2.")
    ensure_ec2_gress(sg_id, region)
    return sg_id


def select_subnet(region):
    """
    Picks the first available subnet.
    :param region: The region, or `None` to pull the region from the environment.
    :return: The SubnetId.
    """
    client = make_client("ec2", region)
    return client.describe_subnets(Filters=[])["Subnets"][0]["SubnetId"]


def ensure_role(client, role_name):
    """
    Ensures that a SINGLE matching IAM role exists. Throws a `RuntimeError` if there are multiple
    matching roles.

    :param client: The iam client to use.
    :param role_name: The name of the IAM role.
    :return: The ARN of the matching IAM role, or `None` if there was no matching role.
    """
    roles = client.list_roles(PathPrefix="/")["Roles"]
    matching_roles = [it for it in roles if it["RoleName"] == role_name]
    if len(matching_roles) == 1:
        return matching_roles[0]["Arn"]
    elif len(matching_roles) > 1:
        raise RuntimeError("Found multiple matching roles: {}".format(role_name, roles))
    else:
        return None


def ensure_task_role(region):
    """
    Ensures a task role exists. If there is one matching role, its Arn is returned. If there are
    multiple matching roles, a `RuntimeError` is raised. If there are no matching roles, a new one
    is created.

    TODO: Fix this:
    This method does not check that a matching role has the correct policies.

    :param region: The region, or `None` to pull the region from the environment.
    :return: The role Arn.
    """
    role_name = "axon-autogenerated-ecs-task-role"
    client = make_client("iam", region)
    role_arn = ensure_role(client, role_name)
    if role_arn is None:
        # Need to create the role
        role = client.create_role(
            Path="/",
            RoleName=role_name,
            AssumeRolePolicyDocument=json.dumps({
                "Version": "2012-10-17",
                "Statement": [
                    {
                        "Sid": "",
                        "Effect": "Allow",
                        "Principal": {
                            "Service": "ecs-tasks.amazonaws.com"
                        },
                        "Action": "sts:AssumeRole"
                    }
                ]
            })
        )["Role"]

        role_arn = role["Arn"]

        client.attach_role_policy(RoleName=role_name,
                                  PolicyArn="arn:aws:iam::aws:policy/service-role/"
                                            "AmazonECSTaskExecutionRolePolicy")
        client.attach_role_policy(RoleName=role_name,
                                  PolicyArn="arn:aws:iam::aws:policy/AmazonEC2FullAccess")
        client.attach_role_policy(RoleName=role_name,
                                  PolicyArn="arn:aws:iam::aws:policy/AmazonS3FullAccess")
    return role_arn


def ensure_ec2_role(region, role_name="axon-autogenerated-ec2-role"):
    """
    Ensures the EC2 role exists. Creates the role if it does not exist.

    :param region: The region, or `None` to pull the region from the environment.
    :param role_name: The name of the role to ensure.
    :return: The role Arn.
    """
    client = make_client("iam", region)
    role_arn = ensure_role(client, role_name)
    if role_arn is None:
        # Need to create the role
        role = client.create_role(
            Path="/",
            RoleName=role_name,
            AssumeRolePolicyDocument=json.dumps({
                "Version": "2012-10-17",
                "Statement": [
                    {
                        "Effect": "Allow",
                        "Principal": {
                            "Service": "ec2.amazonaws.com"
                        },
                        "Action": "sts:AssumeRole"
                    }
                ]
            })
        )["Role"]

        role_arn = role["Arn"]

        client.attach_role_policy(RoleName=role_name,
                                  PolicyArn="arn:aws:iam::aws:policy/AmazonS3FullAccess")

    return role_arn


def ensure_ec2_instance_profile(region, profile_name="axon-autogenerated-ec2-instance-profile",
                                role_name="axon-autogenerated-ec2-role"):
    """
    Ensures the EC2 instance profile exists and has the EC2 role attached.

    :param region: The region, or `None` to pull the region from the environment.
    :param profile_name: The name of the instance profile to ensure.
    :param role_name: The name of the role to ensure.
    :return: The instance profile Arn.
    """
    client = make_client("iam", region)
    iam_resource = make_resource('iam')

    # Get or create the instance profile
    try:
        local_profile = client.get_instance_profile(InstanceProfileName=profile_name)
    except:
        local_profile = client.create_instance_profile(InstanceProfileName=profile_name)

    instance_profile = iam_resource.InstanceProfile(
        local_profile['InstanceProfile']['InstanceProfileName'])

    if role_name not in [role.name for role in instance_profile.roles]:
        # Add the role if it does not exist
        instance_profile.add_role(RoleName=role_name)

    return instance_profile.arn


def ensure_s3_bucket(region):
    """
    Ensures that a matching S3 bucket exists.

    :param region: The region, or `None` to pull the region from the environment.
    :return: The name of the bucket.
    """
    client = make_client("s3", region)
    prefix = "axon-autogenerated-"  # Used to identify the bucket that Axon manages

    def get_axon_bucket():
        buckets = client.list_buckets()["Buckets"]

        # Return the first matching bucket name, if there is one
        for bucket in buckets:
            if bucket["Name"].startswith(prefix):
                return bucket["Name"]

        return None

    axon_bucket = get_axon_bucket()
    if axon_bucket is not None:
        return axon_bucket

    # There is no matching bucket name, so create a new one
    import random
    import string
    while True:
        bucket_name = prefix + ''.join(
            random.choice(string.ascii_lowercase + string.digits) for _ in range(30))

        # If the user wants a region in this list, we need to set it
        if region in ['EU', 'eu-west-1', 'us-west-1', 'us-west-2',
                      'ap-south-1', 'ap-southeast-1', 'ap-southeast-2',
                      'ap-northeast-1', 'sa-east-1', 'cn-north-1',
                      'eu-central-1']:
            client.create_bucket(ACL='private', Bucket=bucket_name,
                                 CreateBucketConfiguration={'LocationConstraint': region})
        else:
            # Otherwise the region will be us-east-1
            client.create_bucket(ACL='private', Bucket=bucket_name)

        # Busy loop until the bucket is created. Otherwise, we will set the public access block
        # too early and its configuration will be lost
        while True:
            axon_bucket = get_axon_bucket()
            if axon_bucket is not None:
                break

        client.put_public_access_block(Bucket=bucket_name, PublicAccessBlockConfiguration={
            'BlockPublicAcls': True,
            'IgnorePublicAcls': True,
            'BlockPublicPolicy': True,
            'RestrictPublicBuckets': True
        })

        return bucket_name


def ensure_cluster(ecs_client, cluster_name):
    """
    Ensures that a matching cluster exists. If there are no matching clusters, one is created.

    :param ecs_client: The ECS client to use.
    :param cluster_name: The simple name of the cluster.
    :return: Nothing.
    """
    clusters = ecs_client.describe_clusters(clusters=[cluster_name])["clusters"]
    if len([it for it in clusters if it["clusterName"] == cluster_name]) == 0:
        ecs_client.create_cluster(clusterName=cluster_name)


def ensure_task(ecs_client, task_family, region, vcpu, memory):
    """
    Ensures that a matching task definition exists. If there is at least one match, its Arn is
    returned. If there are no matches, a new task definition is created.

    This method does not check that a matching task definition has up-to-date values for the task
    role, cpu, memory, etc.

    :param ecs_client: The ECS client to use.
    :param task_family: The task family name.
    :param region: The region, or `None` to pull the region from the environment.
    :param vcpu: The amount of cpu in vcpu units.
    :param memory: The amount of memory in MB.
    :return: The task definition's Arn.
    """
    def_arns = ecs_client.list_task_definitions(
        familyPrefix=task_family,
        sort="DESC"
    )["taskDefinitionArns"]

    matching_arns = [it for it in def_arns if it.split("/")[-1].split(":")[0] == task_family]

    if len(matching_arns) != 0:
        # There is at least one matching task definition, so we don't need to create one
        return matching_arns[0]
    else:
        # There are no matching task definitions, so make one
        log_group_name = "/ecs/{}".format(task_family)
        ensure_log_group(log_group_name, region)

        role_arn = ensure_task_role(region)

        reg_response = ecs_client.register_task_definition(
            family=task_family,
            taskRoleArn=role_arn,
            executionRoleArn=role_arn,
            networkMode="awsvpc",
            containerDefinitions=[
                {
                    "name": "axon-hosted",
                    "image": "wpilib/axon-hosted",
                    "essential": True,
                    "logConfiguration": {
                        "logDriver": "awslogs",
                        "options": {
                            "awslogs-group": log_group_name,
                            "awslogs-region": region,
                            "awslogs-stream-prefix": "ecs"
                        }
                    }
                }
            ],
            requiresCompatibilities=["FARGATE"],
            cpu=str(vcpu),
            memory=str(memory)
        )

        return reg_response["taskDefinition"]["taskDefinitionArn"]


def wait_for_task_to_start(task_arn, cluster, region):
    """
    Waits for a task to transition to the RUNNING state.

    :param task_arn: The Arn of the task to wait for.
    :param cluster: The simple name of the cluster the task is in.
    :param region: The region, or `None` to pull the region from the environment.
    :return: Nothing.
    """
    client = make_client("ecs", region)
    waiter = client.get_waiter("tasks_running")
    waiter.wait(cluster=cluster, tasks=[task_arn])


def impl_ensure_configuration(cluster_name, task_family, region):
    """
    Ensures all the configuration Axon needs is in place.

    :param cluster_name: The simple name of the cluster to start the task in.
    :param task_family: The family of the task to start.
    :param region: The region, or `None` to pull the region from the environment.
    """
    client = make_client("ecs", region)
    ensure_s3_bucket(region)
    ensure_cluster(client, cluster_name)
    ensure_task(client, task_family, region, 2048, 4096)
    ensure_ec2_security_group(region)
    ensure_ecs_security_group(region)
    ensure_task_role(region)
    ensure_ec2_role(region)
    ensure_ec2_instance_profile(region)


def impl_start_task(cluster_name, task_family, revision, region):
    """
    Starts a task. Creates the cluster, task, and security group if they are not present. Selects
    the first available subnet.

    Raises a RuntimeError if the task failed to start or if more than one task was started.

    :param cluster_name: The simple name of the cluster to start the task in.
    :param task_family: The family of the task to start.
    :param revision: A task definition revision number, or None to use the latest revision.
    :param region: The region, or `None` to pull the region from the environment.
    :return: The started task's Arn.
    """
    client = make_client("ecs", region)

    impl_ensure_configuration(cluster_name, task_family, region)

    sg_id = ensure_ecs_security_group(region)
    subnet_id = select_subnet(region)

    run_response = client.run_task(
        cluster=cluster_name,
        taskDefinition=task_family if revision is None else "{}:{}".format(task_family, revision),
        launchType="FARGATE",
        networkConfiguration={
            "awsvpcConfiguration": {
                "subnets": [subnet_id],
                "securityGroups": [sg_id],
                "assignPublicIp": "ENABLED"
            }
        }
    )

    tasks = run_response["tasks"]

    if len(tasks) == 0:
        raise RuntimeError("Failed to start task: {}".format(run_response))
    if len(tasks) > 1:
        raise RuntimeError("Started more than one task: {}".format(tasks))
    else:
        return tasks[0]["taskArn"]


def impl_stop_task(cluster_name, task_arn, region):
    """
    Stops a task.

    :param cluster_name: The simple name of the cluster.
    :param task_arn: The Arn of the task.
    :param region: The region, or `None` to pull the region from the environment.
    :return: Nothing.
    """
    client = make_client("ecs", region)
    client.stop_task(cluster=cluster_name, task=task_arn)


def impl_get_task_ip(cluster_name, task_arn, region):
    """
    Reads the public IP of a task. This is probably only valid for tasks that have one container.

    :param cluster_name: The simple name of the cluster.
    :param task_arn: The task's Arn.
    :param region: The region, or `None` to pull the region from the environment.
    :return: The public IP of the task.
    """
    client = make_client("ecs", region)
    task_arn = client.describe_tasks(
        cluster=cluster_name,
        tasks=[task_arn]
    )["tasks"][0]

    interface_attachment = next(
        x for x in task_arn["attachments"] if x["type"] == "ElasticNetworkInterface")
    eni = next(
        x["value"] for x in interface_attachment["details"] if x["name"] == "networkInterfaceId")

    ec2 = make_client("ec2", region)
    nics = ec2.describe_network_interfaces(
        Filters=[
            {
                "Name": "network-interface-id",
                "Values": [eni]
            }
        ]
    )["NetworkInterfaces"]
    return nics[0]["Association"]["PublicIp"]


def impl_upload_untrained_model(model_path, bucket_name, region):
    """
    Uploads an untrained model to S3.

    :param model_path: The file path to the model to upload, ending with the name of the model.
    :param bucket_name: The S3 bucket name.
    :param region: The region, or `None` to pull the region from the environment.
    """
    client = make_client("s3", region)
    key = "axon-untrained-models/" + os.path.basename(model_path)
    client.upload_file(model_path, bucket_name, key)
    print("Uploaded to: {}\n".format(key))


def impl_download_untrained_model(model_path, bucket_name, region):
    """
    Downloads an untrained model from S3.

    :param model_path: The file path to download to, ending with the name of the model.
    :param bucket_name: The S3 bucket name.
    :param region: The region, or `None` to pull the region from the environment.
    """
    client = make_client("s3", region)
    key = "axon-untrained-models/" + os.path.basename(model_path)
    client.download_file(bucket_name, key, model_path)
    print("Downloaded from: {}\n".format(key))


def impl_upload_trained_model(model_path, bucket_name, region):
    """
    Uploads an trained model to S3.

    :param model_path: The file path to the model to upload, ending with the name of the model.
    :param bucket_name: The S3 bucket name.
    :param region: The region, or `None` to pull the region from the environment.
    """
    client = make_client("s3", region)
    key = "axon-trained-models/" + os.path.basename(model_path)
    client.upload_file(model_path, bucket_name, key)
    print("Uploaded to: {}\n".format(key))


def impl_download_trained_model(model_path, bucket_name, region):
    """
    Downloads an trained model from S3.

    :param model_path: The file path to download to, ending with the name of the model.
    :param bucket_name: The S3 bucket name.
    :param region: The region, or `None` to pull the region from the environment.
    """
    client = make_client("s3", region)
    key = "axon-trained-models/" + os.path.basename(model_path)
    client.download_file(bucket_name, key, model_path)
    print("Downloaded from: {}\n".format(key))


def impl_download_training_script(script_path, bucket_name, region):
    """
    Downloads a training script from S3.

    :param script_path: The file path to download to, ending with the name of the script.
    :param bucket_name: The S3 bucket name.
    :param region: The region, or `None` to pull the region from the environment.
    """
    client = make_client("s3", region)
    key = "axon-training-scripts/" + os.path.basename(script_path)
    client.download_file(bucket_name, key, script_path)
    print("Downloaded from: {}\n".format(key))


def impl_upload_dataset(dataset_path, bucket_name, region):
    """
    Uploads a dataset to S3.

    :param dataset_path: The file path to the dataset to upload, ending with the name of the
    dataset.
    :param bucket_name: The S3 bucket name.
    :param region: The region, or `None` to pull the region from the environment.
    """
    client = make_client("s3", region)
    key = "axon-datasets/" + os.path.basename(dataset_path)
    client.upload_file(dataset_path, bucket_name, key)
    print("Uploaded to: {}\n".format(key))


def impl_download_dataset(dataset_path, bucket_name, region):
    """
    Downloads a dataset from S3.

    :param dataset_path: The file path to download to, ending with the name of the dataset.
    :param bucket_name: The S3 bucket name.
    :param region: The region, or `None` to pull the region from the environment.
    """
    client = make_client("s3", region)
    key = "axon-datasets/" + os.path.basename(dataset_path)
    client.download_file(bucket_name, key, dataset_path)
    print("Downloaded from: {}\n".format(key))


def impl_update_training_progress(job_id, progress_text, bucket_name, region):
    """
    Updates the training progress in S3 for a model specified by its name.

    :param job_id: The unique Job ID.
    :param progress_text: The text to write into the progress file.
    :param bucket_name: The S3 bucket name.
    :param region: The region, or `None` to pull the region from the environment.
    """
    local_file, path = tempfile.mkstemp()
    try:
        with open(local_file, "w") as f:
            f.write(progress_text)
        client = make_client("s3", region)
        remote_path = create_progress_prefix(job_id) + "/progress.txt"
        client.upload_file(path, bucket_name, remote_path)
        print("Updated progress in: {}\n".format(remote_path))
    finally:
        os.remove(path)


def impl_create_heartbeat(job_id, bucket_name, region):
    """
    Creates a heartbeat that Axon uses to check if the training script is running properly.

    :param job_id: The unique Job ID.
    :param bucket_name: The S3 bucket name.
    :param region: The region, or `None` to pull the region from the environment.
    """
    client = make_client("s3", region)
    remote_path = create_progress_prefix(job_id) + "/heartbeat.txt"
    client.put_object(Body="1", Bucket=bucket_name, Key=remote_path)
    print("Created heartbeat file in: {}\n".format(remote_path))


def impl_remove_heartbeat(job_id, bucket_name, region):
    """
    Removes a heartbeat that Axon uses to check if the training script is running properly.

    :param job_id: The unique Job ID.
    :param bucket_name: The S3 bucket name.
    :param region: The region, or `None` to pull the region from the environment.
    """
    client = make_client("s3", region)
    remote_path = create_progress_prefix(job_id) + "/heartbeat.txt"
    client.put_object(Body="0", Bucket=bucket_name, Key=remote_path)
    print("Removed heartbeat file in: {}\n".format(remote_path))


def create_progress_prefix(job_id):
    return "axon-training-progress/" + job_id


@click.group()
def cli():
    return


region_choices = ['us-east-1', 'us-east-2', 'us-west-1', 'us-west-2', 'ca-central-1',
                  'eu-central-1', 'eu-west-1', 'eu-west-2', 'eu-west-3',
                  'eu-north-1', 'ap-east-1', 'ap-south-1', 'ap-northeast-1',
                  'ap-northeast-2', 'ap-northeast-3', 'ap-southeast-1',
                  'ap-southeast-2', 'me-south-1', 'sa-east-1']


@cli.command(name="start-axon")
@click.option("--region", help="The region to connect to.",
              type=click.Choice(region_choices))
@click.option("--revision", default=None,
              help="The revision of the task. Set to None to use the latest revision.")
def start_axon(revision, region):
    """
    Starts Axon and opens the ECS server in the default web browser.
    """
    cluster_name = "axon-autogenerated-cluster"
    task_family = "axon-autogenerated-task-family"
    impl_ensure_configuration(cluster_name, task_family, region)
    task_arn = impl_start_task(cluster_name, task_family, revision, region)
    print("Started task: {}".format(task_arn))
    print("Waiting for task to start...")
    wait_for_task_to_start(task_arn, cluster_name, region)
    print("Started")
    ip = impl_get_task_ip(cluster_name, task_arn, region)
    # TODO: How do we wait for Axon to start running?
    webbrowser.open("http://{}:8080/axon/dataset".format(ip), 2)


@cli.command(name="ensure-configuration")
@click.option("--region", help="The region to connect to.",
              type=click.Choice(region_choices))
def ensure_configuration(region):
    """
    Ensures that AWS is configured for Axon.
    """
    impl_ensure_configuration("axon-autogenerated-cluster", "axon-autogenerated-task-family",
                              region)


@cli.command(name="start-task")
@click.option("--region", help="The region to connect to.",
              type=click.Choice(region_choices))
@click.option("--revision", default=None,
              help="The revision of the task. Set to None to use the latest revision.")
@click.option("--stop-after/--no-stop-after", default=False,
              help="Whether to stop the task immediately after creating it.")
def start_task(revision, region, stop_after):
    """
    Starts a task.
    """
    cluster_name = "axon-autogenerated-cluster"
    task_family = "axon-autogenerated-task-family"
    impl_ensure_configuration(cluster_name, task_family, region)
    task_arn = impl_start_task(cluster_name, task_family, revision, region)
    print("Started task: {}".format(task_arn))
    if stop_after:
        impl_stop_task(cluster_name, task_arn, region)
    else:
        print("Waiting for task to start...")
        wait_for_task_to_start(task_arn, cluster_name, region)
        print("Started")


@cli.command(name="stop-task")
@click.argument("task-arn")
@click.option("--region", help="The region to connect to.",
              type=click.Choice(region_choices))
def stop_task(task_arn, region):
    """
    Stops a task.

    TASK_ARN The ARN of the task to stop. Given to you from `start_task` or `start_axon`.
    """
    impl_stop_task("axon-autogenerated-cluster", task_arn, region)


@cli.command(name="get-container-ip")
@click.argument("task-arn")
@click.option("--region", help="The region to connect to.",
              type=click.Choice(region_choices))
def get_container_ip(task_arn, region):
    """
    Gets the IP of the container the task is running on.

    TASK_ARN The ARN of the task.
    """
    print(impl_get_task_ip("axon-autogenerated-cluster", task_arn, region))


@cli.command(name="upload-untrained-model")
@click.argument("model-path")
@click.option("--region", help="The region to connect to.",
              type=click.Choice(region_choices))
def upload_untrained_model(model_path, region):
    """
    Uploads an untrained model from a local file.

    MODEL_PATH The path to the model to upload, ending with the name of the model.
    """
    impl_upload_untrained_model(model_path, ensure_s3_bucket(region), region)


@cli.command(name="download-untrained-model")
@click.argument("model-path")
@click.option("--region", help="The region to connect to.",
              type=click.Choice(region_choices))
def download_untrained_model(model_path, region):
    """
    Downloads an untrained model to a local file.

    MODEL_PATH The path to download the model to, ending with the name of the model.
    """
    impl_download_untrained_model(model_path, ensure_s3_bucket(region), region)


@cli.command(name="upload-trained-model")
@click.argument("model-path")
@click.option("--region", help="The region to connect to.",
              type=click.Choice(region_choices))
def upload_trained_model(model_path, region):
    """
    Uploads a trained model from a local file.

    MODEL_PATH The path to the model to upload, ending with the name of the model.
    """
    impl_upload_trained_model(model_path, ensure_s3_bucket(region), region)


@cli.command(name="download-trained-model")
@click.argument("model-path")
@click.option("--region", help="The region to connect to.",
              type=click.Choice(region_choices))
def download_trained_model(model_path, region):
    """
    Downloads a trained model to a local file.

    MODEL_PATH The path to download the model to, ending with the name of the model.
    """
    impl_download_trained_model(model_path, ensure_s3_bucket(region), region)


@cli.command(name="download-training-script")
@click.argument("script-path")
@click.option("--region", help="The region to connect to.",
              type=click.Choice(region_choices))
def download_training_script(script_path, region):
    """
    Downloads a training script.

    SCRIPT_PATH The path to download the script to, ending with the name of the script.
    """
    impl_download_training_script(script_path, ensure_s3_bucket(region), region)


@cli.command(name="upload-dataset")
@click.argument("dataset-path")
@click.option("--region", help="The region to connect to.",
              type=click.Choice(region_choices))
def upload_dataset(dataset_path, region):
    """
    Uploads a dataset.

    DATASET_PATH The path to the dataset to upload, ending with the name of the dataset.
    """
    impl_upload_dataset(dataset_path, ensure_s3_bucket(region), region)


@cli.command(name="download-dataset")
@click.argument("dataset-path")
@click.option("--region", help="The region to connect to.",
              type=click.Choice(region_choices))
def download_dataset(dataset_path, region):
    """
    Downloads a dataset.

    DATASET_PATH The path to download the dataset to, ending with the name of the dataset.
    """
    impl_download_dataset(dataset_path, ensure_s3_bucket(region), region)


@cli.command(name="update-training-progress")
@click.argument("job-id")
@click.argument("progress-text")
@click.option("--region", help="The region to connect to.",
              type=click.Choice(region_choices))
def update_training_progress(job_id, progress_text, region):
    """
    Updates the training progress. Meant to be used while a training script is running to provide
    progress updates to Axon.

    JOB_ID The unique Job ID.

    PROGRESS_TEXT The text to write to the progress file.
    """
    impl_update_training_progress(job_id, progress_text, ensure_s3_bucket(region),
                                  region)


@cli.command(name="create-heartbeat")
@click.argument("job-id")
@click.option("--region", help="The region to connect to.",
              type=click.Choice(region_choices))
def create_heartbeat(job_id, region):
    """
    Creates a heartbeat that Axon uses to check if the training script is running properly.

    JOB_ID The unique Job ID.
    """
    impl_create_heartbeat(job_id, ensure_s3_bucket(region), region)


@cli.command(name="remove-heartbeat")
@click.argument("job-id")
@click.option("--region", help="The region to connect to.",
              type=click.Choice(region_choices))
def remove_heartbeat(job_id, region):
    """
    Removes a heartbeat that Axon uses to check if the training script is running properly.

    JOB_ID The unique Job ID.
    """
    impl_remove_heartbeat(job_id, ensure_s3_bucket(region), region)
